//
// Trimmer Framework for Unity - https://sttz.ch/trimmer
// Copyright Â© 2017 Adrian Stutz
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

#if UNITY_EDITOR

using sttz.Trimmer.BaseOptions;
using sttz.Trimmer.Extensions;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;
using System.Reflection;

namespace sttz.Trimmer.Options
{

/// <summary>
/// Collection of patches to the XCode project generated by Unity.
/// </summary>
/// <remarks>
/// This collection of patches addresses some annoyances with the XCode project
/// generated by Unity.
/// 
/// Included are:
/// * <see cref="OptionForceDisableRemoteNotifications"/>
/// * <see cref="OptionAddEncryptionExemption"/>
/// * <see cref="OptionRenameScheme"/>
/// </remarks>
[Capabilities(OptionCapabilities.ConfiguresBuild)]
public class OptionXcode : OptionContainer
{
    protected override void Configure()
    {
        Category = "Build";

        SupportedTargets = new BuildTarget[] {
            BuildTarget.iOS
        };
    }

    /// <summary>
    /// Older versions of Unity had the issue that they mis-detected the
    /// usage of remote notifications, which would trigger an error email
    /// with iTunes Connect if the entitilement wasn't present.
    /// 
    /// This Option force disables remote notifications, only enable if
    /// you know you don't use them!
    /// </summary>
    public class OptionForceDisableRemoteNotifications : OptionToggle
    {
        override public void PostprocessBuild(BuildTarget target, string path, OptionInclusion inclusion)
        {
            base.PostprocessBuild(target, path, inclusion);

            if (!Value) return;

            var preprocessorPath = System.IO.Path.Combine(path, "Classes/Preprocessor.h");
            if (!File.Exists(preprocessorPath)) {
                Debug.LogError("Could not find Preprocessor.h at path: " + preprocessorPath);
                return;
            }

            var contents = File.ReadAllText(preprocessorPath, Encoding.UTF8);
            if (!contents.Contains("#define UNITY_USES_REMOTE_NOTIFICATIONS ")) {
                Debug.LogError("Could not find UNITY_USES_REMOTE_NOTIFICATIONS define in Preprocessor.h");
                return;
            } else if (!contents.Contains("#define UNITY_USES_REMOTE_NOTIFICATIONS 1")) {
                Debug.Log("Remote notifications already disabled, nothing to do.");
                return;
            }

            contents = contents.Replace(
                "#define UNITY_USES_REMOTE_NOTIFICATIONS 1",
                "#define UNITY_USES_REMOTE_NOTIFICATIONS 0"
            );
            File.WriteAllText(preprocessorPath, contents);

            Debug.Log("Force disabled remote notifications.");
        }
    }

    /// <summary>
    /// This Option sets `ITSAppUsesNonExemptEncryption` to `false` in
    /// the plist, indicating the app doesn't use any non-exempt encryption.
    /// Only enable this after familiarizing yourself with the export
    /// restrictions, the exemptions and the paperwork requirements.
    /// </summary>
    public class OptionAddEncryptionExemption : OptionToggle
    {
        override public void PostprocessBuild(BuildTarget target, string path, OptionInclusion inclusion)
        {
            base.PostprocessBuild(target, path, inclusion);

            if (!Value) return;

            var plistPath = System.IO.Path.Combine(path, "Info.plist");
            if (!File.Exists(plistPath)) {
                Debug.LogError("Could not find Info.plist at path: " + plistPath);
                return;
            }

            // We use reflection here to use the PlistDocument class
            // because it's only available if the iOS plugin is installed.
            // We could use #if UNITY_IOS but then the user would have to
            // remember to switch the active platform to iOS before building,
            // because the editor code will only be recompiled afterwards.
            // (tested on Unity 5.6)
            var assembly = AppDomain.CurrentDomain.GetAssemblies()
                .Where(a => a.GetName().Name == "UnityEditor.iOS.Extensions.Xcode")
                .FirstOrDefault();
            if (assembly == null) {
                Debug.LogError("Could not find UnityEditor.iOS.Extensions.Xcode assembly.");
                return;
            }

            var PlistDocument = assembly.GetType("UnityEditor.iOS.Xcode.PlistDocument");
            if (PlistDocument == null) {
                Debug.LogError("Could not find PlistDocument class.");
                return;
            }

            var PlistElementDict = assembly.GetType("UnityEditor.iOS.Xcode.PlistElementDict");
            if (PlistElementDict == null) {
                Debug.LogError("Could not find PlistElementDict class.");
                return;
            }

            var ReadFromFile = PlistDocument.GetMethod("ReadFromFile", BindingFlags.Instance | BindingFlags.Public);
            if (ReadFromFile == null) {
                Debug.LogError("Could not find ReadFromFile method on PlistDocument class.");
                return;
            }

            var WriteToFile = PlistDocument.GetMethod("WriteToFile", BindingFlags.Instance | BindingFlags.Public);
            if (WriteToFile == null) {
                Debug.LogError("Could not find WriteToFile method on PlistDocument class.");
                return;
            }

            var root = PlistDocument.GetField("root", BindingFlags.Instance | BindingFlags.Public);
            if (root == null) {
                Debug.LogError("Could not find root field on PlistDocument class.");
                return;
            }

            var SetBoolean = PlistElementDict.GetMethod("SetBoolean", BindingFlags.Instance | BindingFlags.Public);
            if (SetBoolean == null) {
                Debug.LogError("Could not find SetBoolean method on PlistElementDict class.");
                return;
            }

            var info = Activator.CreateInstance(PlistDocument);
            ReadFromFile.Invoke(info, new object[] { plistPath });

            var rootValue = root.GetValue(info);
            SetBoolean.Invoke(rootValue, new object[] { "ITSAppUsesNonExemptEncryption", false });

            WriteToFile.Invoke(info, new object[] { plistPath });

            Debug.Log("Added Info.plist entry indicating the app only uses exempt encryption.");
        }
    }

    /// <summary>
    /// This Option is only cosmetical. It renames the scheme in the generated
    /// XCode project to the product name set in Unity. This will display your
    /// product name in XCode's scheme selection in the title bar and especially
    /// in the organizer side bar (instead of Unity-iPhone for all projects).
    /// </summary>
    public class OptionRenameScheme : OptionToggle
    {
        override public void PostprocessBuild(BuildTarget target, string path, OptionInclusion inclusion)
        {
            base.PostprocessBuild(target, path, inclusion);

            if (!Value) return;

            var projectPath = System.IO.Path.Combine(path, "Unity-iPhone.xcodeproj");
            if (!Directory.Exists(projectPath)) {
                Debug.LogError("Could not find Unity-iPhone.xcodeproj at path: " + projectPath);
                return;
            }

            var basePath = System.IO.Path.Combine(projectPath, "xcshareddata/xcschemes");
            var schemePath = System.IO.Path.Combine(basePath, "Unity-iPhone.xcscheme");
            if (!File.Exists(schemePath)) {
                Debug.Log("No default Unity scheme at path, possibly already renamed: " + schemePath);
                return;
            }

            var newName = System.IO.Path.Combine(basePath, Application.productName + ".xcscheme");
            File.Move(schemePath, newName);

            Debug.Log("Renamed Unity's default scheme to " + Application.productName);
        }
    }
}

}
#endif